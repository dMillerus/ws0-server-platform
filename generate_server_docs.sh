#!/bin/bash

#===============================================================================
# Script Name: generate_server_docs.sh
# Description: Comprehensive Linux server documentation generator
# Author: System Documentation Assistant
# Version: 1.0
# Date: $(date +"%Y-%m-%d")
#
# Purpose: Collects detailed system information from any modern Linux server
#          and generates a comprehensive Markdown documentation file.
#
# Usage: ./generate_server_docs.sh
# Output: SERVER_DOCUMENTATION.md (configurable via OUTPUT_FILE variable)
#
# Requirements: Standard Linux utilities (lsb_release, lscpu, free, df, ip, etc.)
#===============================================================================

# Script configuration
set -euo pipefail  # Exit on error, undefined vars, pipe failures
OUTPUT_FILE="SERVER_DOCUMENTATION.md"
TEMP_DIR=$(mktemp -d)
SCRIPT_START_TIME=$(date)

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Cleanup function
cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Logging function
log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check required commands
check_requirements() {
    log "Checking required commands..."
    local required_commands=(
        "hostname" "date" "uname" "lscpu" "free" "df" "lsblk"
        "ip" "ss" "ps" "cat" "grep" "awk" "sort" "head" "tail"
        "getent" "lastlog" "systemctl"
    )
    
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "$cmd"; then
            missing_commands+=("$cmd")
        fi
    done
    
    # Check for package manager
    local pkg_manager=""
    if command_exists "dpkg"; then
        pkg_manager="dpkg"
    elif command_exists "rpm"; then
        pkg_manager="rpm"
    elif command_exists "pacman"; then
        pkg_manager="pacman"
    else
        missing_commands+=("dpkg or rpm or pacman")
    fi
    
    if [ ${#missing_commands[@]} -ne 0 ]; then
        error "Missing required commands: ${missing_commands[*]}"
        error "Please install missing packages and try again."
        exit 1
    fi
    
    log "All required commands are available."
}

# Initialize output file
init_output_file() {
    log "Initializing output file: $OUTPUT_FILE"
    cat > "$OUTPUT_FILE" << 'EOF'
# Server Documentation

**Generated on:** $(date)  
**Hostname:** $(hostname)  
**Generated by:** generate_server_docs.sh

## Table of Contents

1. [System Overview](#1-system-overview)
2. [Hardware](#2-hardware)
3. [Network](#3-network)
4. [Installed Packages](#4-installed-packages)
5. [Running Services & Processes](#5-running-services--processes)
6. [Open Ports & Firewall Rules](#6-open-ports--firewall-rules)
7. [User Accounts](#7-user-accounts)
8. [Scheduled Tasks](#8-scheduled-tasks)
9. [Security Configuration](#9-security-configuration)
10. [Containers & Virtualization](#10-containers--virtualization)
11. [Logs Summary](#11-logs-summary)
12. [Backup & Monitoring Agents](#12-backup--monitoring-agents)
13. [Known Issues & Notes](#13-known-issues--notes)

---

EOF
    
    # Replace placeholders with actual values
    sed -i "s/\$(date)/$SCRIPT_START_TIME/" "$OUTPUT_FILE"
    sed -i "s/\$(hostname)/$(hostname)/" "$OUTPUT_FILE"
}

# Section 1: System Overview
generate_system_overview() {
    log "Generating system overview..."
    cat >> "$OUTPUT_FILE" << EOF

## 1. System Overview

| Attribute | Value |
|-----------|-------|
| **Date/Time of Run** | $SCRIPT_START_TIME |
| **Hostname** | $(hostname) |
| **FQDN** | $(hostname -f 2>/dev/null || echo "N/A") |
| **Operating System** | $(if command_exists lsb_release; then lsb_release -d | cut -f2; else cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2; fi) |
| **Kernel Version** | $(uname -r) |
| **Architecture** | $(uname -m) |
| **Uptime** | $(uptime -p 2>/dev/null || uptime | awk '{print $3,$4}' | sed 's/,//') |

EOF
}

# Section 2: Hardware
generate_hardware_info() {
    log "Generating hardware information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 2. Hardware

### CPU Information
```
EOF
    lscpu | grep -E "(Model name|CPU\(s\)|Thread|Socket|Core)" >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Memory Information
```
EOF
    free -h >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Disk Layout
```
EOF
    lsblk >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Disk Usage
```
EOF
    df -h >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 3: Network
generate_network_info() {
    log "Generating network information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 3. Network

### Network Interfaces
```
EOF
    ip addr show >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Routing Table
```
EOF
    ip route >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### DNS Configuration
```
EOF
    if [ -f /etc/resolv.conf ]; then
        cat /etc/resolv.conf >> "$OUTPUT_FILE"
    else
        echo "DNS configuration file not found" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 4: Installed Packages
generate_packages_info() {
    log "Generating installed packages information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 4. Installed Packages

### Package Count
EOF
    
    if command_exists dpkg; then
        local total_packages=$(dpkg -l | grep "^ii" | wc -l)
        echo "**Total Installed Packages (dpkg):** $total_packages" >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'

### Top 10 Largest Packages
```
EOF
        dpkg-query -W -f='${Installed-Size}\t${Package}\t${Version}\n' | sort -nr | head -10 | awk '{printf "%-10s %-30s %s\n", $1"KB", $2, $3}' >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'
```

### All Installed Packages
```
EOF
        dpkg -l | grep "^ii" | awk '{printf "%-30s %-20s %s\n", $2, $3, $4}' >> "$OUTPUT_FILE"
    elif command_exists rpm; then
        local total_packages=$(rpm -qa | wc -l)
        echo "**Total Installed Packages (rpm):** $total_packages" >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'

### Top 10 Largest Packages
```
EOF
        rpm -qa --queryformat '%{SIZE}\t%{NAME}\t%{VERSION}\n' | sort -nr | head -10 | awk '{printf "%-10s %-30s %s\n", int($1/1024)"KB", $2, $3}' >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'
```

### All Installed Packages
```
EOF
        rpm -qa --queryformat '%-30s %-20s\n' '%{NAME}' '%{VERSION}' | sort >> "$OUTPUT_FILE"
    elif command_exists pacman; then
        log "Counting packages..."
        local total_packages=$(pacman -Q | wc -l)
        echo "**Total Installed Packages (pacman):** $total_packages" >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'

### Sample Packages (First 10)
```
EOF
        # Simpler approach for pacman - just list first 10 packages by name
        log "Getting sample packages..."
        pacman -Q | head -10 | awk '{printf "%-30s %-20s\n", $1, $2}' >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'
```

### All Installed Packages
```
EOF
        log "Getting all packages (limited to first 50)..."
        pacman -Q | head -50 | awk '{printf "%-30s %-20s\n", $1, $2}' >> "$OUTPUT_FILE"
        echo "... (showing first 50 packages, total: $total_packages)" >> "$OUTPUT_FILE"
    fi
    
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
    log "Packages section completed."
}

# Section 5: Running Services & Processes
generate_services_processes() {
    log "Generating services and processes information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 5. Running Services & Processes

### Systemd Services Status
```
EOF
    systemctl list-units --type=service --no-pager >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Top 10 Processes by CPU Usage
```
EOF
    ps aux --sort=-%cpu | head -11 | awk '{printf "%-10s %-6s %-6s %-6s %-8s %s\n", $1, $2, $3, $4, $11, $12}' >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Top 10 Processes by Memory Usage
```
EOF
    ps aux --sort=-%mem | head -11 | awk '{printf "%-10s %-6s %-6s %-6s %-8s %s\n", $1, $2, $3, $4, $11, $12}' >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 6: Open Ports & Firewall Rules
generate_ports_firewall() {
    log "Generating ports and firewall information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 6. Open Ports & Firewall Rules

### Open TCP/UDP Ports
```
EOF
    ss -tulpn >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Firewall Rules
EOF
    
    if command_exists iptables; then
        cat >> "$OUTPUT_FILE" << 'EOF'

#### iptables Rules
```
EOF
        if iptables -L --line-numbers >/dev/null 2>&1; then
            iptables -L --line-numbers >> "$OUTPUT_FILE"
        else
            echo "Unable to read iptables rules (insufficient permissions)" >> "$OUTPUT_FILE"
        fi
        cat >> "$OUTPUT_FILE" << 'EOF'
```
EOF
    fi
    
    if command_exists ufw; then
        cat >> "$OUTPUT_FILE" << 'EOF'

#### UFW Status
```
EOF
        ufw status numbered 2>/dev/null || echo "UFW not configured or accessible" >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'
```
EOF
    fi
    
    echo >> "$OUTPUT_FILE"
}

# Section 7: User Accounts
generate_user_accounts() {
    log "Generating user accounts information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 7. User Accounts

### Local Users
```
EOF
    awk -F: '$3 >= 1000 || $3 == 0 {printf "%-20s %-10s %-10s %s\n", $1, $3, $4, $5}' /etc/passwd >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Sudo-Enabled Users
```
EOF
    if getent group sudo >/dev/null 2>&1; then
        getent group sudo | cut -d: -f4 | tr ',' '\n' >> "$OUTPUT_FILE"
    fi
    if getent group wheel >/dev/null 2>&1; then
        echo "Wheel group members:" >> "$OUTPUT_FILE"
        getent group wheel | cut -d: -f4 | tr ',' '\n' >> "$OUTPUT_FILE"
    fi
    if [ -d /etc/sudoers.d ]; then
        echo "Additional sudoers files:" >> "$OUTPUT_FILE"
        ls -la /etc/sudoers.d/ 2>/dev/null >> "$OUTPUT_FILE" || echo "Cannot access /etc/sudoers.d" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Last Login Information
```
EOF
    lastlog | head -20 >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 8: Scheduled Tasks
generate_scheduled_tasks() {
    log "Generating scheduled tasks information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 8. Scheduled Tasks

### Systemd Timers
```
EOF
    systemctl list-timers --no-pager >> "$OUTPUT_FILE"
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Cron Jobs
EOF
    
    # System crontab
    if [ -f /etc/crontab ]; then
        cat >> "$OUTPUT_FILE" << 'EOF'

#### System Crontab (/etc/crontab)
```
EOF
        cat /etc/crontab >> "$OUTPUT_FILE"
        cat >> "$OUTPUT_FILE" << 'EOF'
```
EOF
    fi
    
    # Cron directories
    for cron_dir in /etc/cron.d /etc/cron.daily /etc/cron.hourly /etc/cron.weekly /etc/cron.monthly; do
        if [ -d "$cron_dir" ] && [ "$(ls -A "$cron_dir" 2>/dev/null)" ]; then
            cat >> "$OUTPUT_FILE" << EOF

#### $cron_dir
\`\`\`
EOF
            ls -la "$cron_dir" >> "$OUTPUT_FILE"
            cat >> "$OUTPUT_FILE" << 'EOF'
```
EOF
        fi
    done
    
    # User crontabs
    cat >> "$OUTPUT_FILE" << 'EOF'

#### User Crontabs
```
EOF
    if command_exists crontab; then
        for user in $(awk -F: '$3 >= 1000 {print $1}' /etc/passwd); do
            crontab -l -u "$user" 2>/dev/null && echo "=== $user ===" || true
        done >> "$OUTPUT_FILE"
        if [ ! -s "$TEMP_DIR/cron_check" ]; then
            echo "No user crontabs found" >> "$OUTPUT_FILE"
        fi
    else
        echo "crontab command not available" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 9: Security Configuration
generate_security_config() {
    log "Generating security configuration..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 9. Security Configuration

### SSH Configuration
```
EOF
    if [ -f /etc/ssh/sshd_config ]; then
        grep -E "^[^#]*(Port|PermitRootLogin|PasswordAuthentication|PubkeyAuthentication|Protocol)" /etc/ssh/sshd_config >> "$OUTPUT_FILE" || echo "No matching SSH configuration found" >> "$OUTPUT_FILE"
    else
        echo "SSH configuration file not found" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### SELinux Status
```
EOF
    if command_exists sestatus; then
        sestatus >> "$OUTPUT_FILE"
    else
        echo "SELinux not installed" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### AppArmor Status
```
EOF
    if command_exists aa-status; then
        aa-status 2>/dev/null >> "$OUTPUT_FILE" || echo "AppArmor status not accessible" >> "$OUTPUT_FILE"
    else
        echo "AppArmor not installed" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 10: Containers & Virtualization
generate_containers_virt() {
    log "Generating containers and virtualization information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 10. Containers & Virtualization

### Docker Containers
```
EOF
    if command_exists docker; then
        docker ps -a 2>/dev/null >> "$OUTPUT_FILE" || echo "Docker not accessible (insufficient permissions or not running)" >> "$OUTPUT_FILE"
    else
        echo "Docker not installed" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Docker Images
```
EOF
    if command_exists docker; then
        docker images 2>/dev/null >> "$OUTPUT_FILE" || echo "Docker images not accessible" >> "$OUTPUT_FILE"
    else
        echo "Docker not installed" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Virtual Machines (libvirt)
```
EOF
    if command_exists virsh; then
        virsh list --all 2>/dev/null >> "$OUTPUT_FILE" || echo "libvirt not accessible (insufficient permissions or not running)" >> "$OUTPUT_FILE"
    else
        echo "libvirt not installed" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### LXC Containers
```
EOF
    if command_exists lxc-ls; then
        lxc-ls --fancy 2>/dev/null >> "$OUTPUT_FILE" || echo "LXC not accessible" >> "$OUTPUT_FILE"
    else
        echo "LXC not installed" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 11: Logs Summary
generate_logs_summary() {
    log "Generating logs summary..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 11. Logs Summary

### Recent System Errors
```
EOF
    # Check different log locations
    for log_file in /var/log/syslog /var/log/messages; do
        if [ -f "$log_file" ]; then
            echo "=== $log_file ===" >> "$OUTPUT_FILE"
            grep -i error "$log_file" 2>/dev/null | tail -10 >> "$OUTPUT_FILE" || echo "No recent errors found" >> "$OUTPUT_FILE"
            break
        fi
    done
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Recent Authentication Failures
```
EOF
    for auth_log in /var/log/auth.log /var/log/secure; do
        if [ -f "$auth_log" ]; then
            echo "=== $auth_log ===" >> "$OUTPUT_FILE"
            grep -i "failed\|failure\|invalid" "$auth_log" 2>/dev/null | tail -10 >> "$OUTPUT_FILE" || echo "No recent authentication failures found" >> "$OUTPUT_FILE"
            break
        fi
    done
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Disk Space Warnings
```
EOF
    df -h | awk '$5 > 80 {print "WARNING: " $6 " is " $5 " full"}' >> "$OUTPUT_FILE"
    if ! df -h | awk '$5 > 80 {print "WARNING: " $6 " is " $5 " full"}' | grep -q WARNING; then
        echo "No disk space warnings (>80% usage)" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 12: Backup & Monitoring Agents
generate_backup_monitoring() {
    log "Generating backup and monitoring agents information..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 12. Backup & Monitoring Agents

### Detected Backup Tools
```
EOF
    local backup_tools=("rsync" "rsnapshot" "borg" "duplicity" "tar" "bacula-fd" "amanda")
    local found_backup=false
    
    for tool in "${backup_tools[@]}"; do
        if command_exists "$tool"; then
            echo "$tool: $(which $tool)" >> "$OUTPUT_FILE"
            found_backup=true
        fi
    done
    
    if [ "$found_backup" = false ]; then
        echo "No common backup tools detected" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Detected Monitoring Agents
```
EOF
    local monitoring_agents=("node_exporter" "datadog-agent" "zabbix_agentd" "nagios" "collectd" "telegraf")
    local found_monitoring=false
    
    for agent in "${monitoring_agents[@]}"; do
        if command_exists "$agent"; then
            echo "$agent: $(which $agent)" >> "$OUTPUT_FILE"
            found_monitoring=true
        elif systemctl is-active "$agent" >/dev/null 2>&1; then
            echo "$agent: Active as systemd service" >> "$OUTPUT_FILE"
            found_monitoring=true
        fi
    done
    
    if [ "$found_monitoring" = false ]; then
        echo "No common monitoring agents detected" >> "$OUTPUT_FILE"
    fi
    cat >> "$OUTPUT_FILE" << 'EOF'
```

EOF
}

# Section 13: Known Issues & Notes
generate_known_issues() {
    log "Generating known issues and notes section..."
    cat >> "$OUTPUT_FILE" << 'EOF'

## 13. Known Issues & Notes

### System Health Checks
```
EOF
    
    # Check for common issues
    local issues_found=false
    
    # Check load average
    local load_avg=$(uptime | awk '{print $(NF-2)}' | sed 's/,//')
    local cpu_count=$(nproc)
    if (( $(echo "$load_avg > $cpu_count" | bc -l 2>/dev/null || echo "0") )); then
        echo "WARNING: High load average ($load_avg) exceeds CPU count ($cpu_count)" >> "$OUTPUT_FILE"
        issues_found=true
    fi
    
    # Check memory usage
    local mem_usage=$(free | awk '/^Mem:/ {printf "%.0f", ($3/$2)*100}')
    if [ "$mem_usage" -gt 90 ]; then
        echo "WARNING: High memory usage (${mem_usage}%)" >> "$OUTPUT_FILE"
        issues_found=true
    fi
    
    # Check for failed systemd services
    if systemctl --failed --no-pager -q; then
        echo "WARNING: Failed systemd services detected:" >> "$OUTPUT_FILE"
        systemctl --failed --no-pager >> "$OUTPUT_FILE"
        issues_found=true
    fi
    
    if [ "$issues_found" = false ]; then
        echo "No immediate system health issues detected" >> "$OUTPUT_FILE"
    fi
    
    cat >> "$OUTPUT_FILE" << 'EOF'
```

### Manual Notes
```
[Add any manual observations, known issues, or important notes here]

- Configuration changes needed:
- Performance concerns:
- Security recommendations:
- Maintenance schedules:
```

---

**Documentation generated by:** generate_server_docs.sh  
**Generation completed:** $(date)
EOF
    
    # Replace the date placeholder
    sed -i "s/\$(date)/$(date)/" "$OUTPUT_FILE"
}

# Main execution function
main() {
    log "Starting server documentation generation..."
    log "Output file: $OUTPUT_FILE"
    
    check_requirements
    init_output_file
    
    generate_system_overview
    generate_hardware_info
    generate_network_info
    generate_packages_info
    generate_services_processes
    generate_ports_firewall
    generate_user_accounts
    generate_scheduled_tasks
    generate_security_config
    generate_containers_virt
    generate_logs_summary
    generate_backup_monitoring
    generate_known_issues
    
    log "Documentation generation completed successfully!"
    log "Output saved to: $OUTPUT_FILE"
    log "File size: $(du -h "$OUTPUT_FILE" | cut -f1)"
}

# Execute main function
main "$@"
